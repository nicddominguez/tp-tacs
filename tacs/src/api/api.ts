/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * TP TACS
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://127.0.0.1:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration = new Configuration();

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AtacarMunicipioBody
 */
export interface AtacarMunicipioBody {
    /**
     * Id del municipio que ataca
     * @type {number}
     * @memberof AtacarMunicipioBody
     */
    idMunicipioAtacante?: number;
    /**
     * Id del municipio atacado
     * @type {number}
     * @memberof AtacarMunicipioBody
     */
    idMunicipioObjetivo?: number;
}
/**
 *
 * @export
 * @interface AtacarMunicipioResponse
 */
export interface AtacarMunicipioResponse {
    /**
     *
     * @type {MunicipioEnJuegoModel}
     * @memberof AtacarMunicipioResponse
     */
    municipioAtacante?: MunicipioEnJuegoModel;
    /**
     *
     * @type {MunicipioEnJuegoModel}
     * @memberof AtacarMunicipioResponse
     */
    municipioAtacado?: MunicipioEnJuegoModel;
}
/**
 * Par de coordenadas en el mundo.
 * @export
 * @interface CoordenadasModel
 */
export interface CoordenadasModel {
    /**
     * Latitud
     * @type {number}
     * @memberof CoordenadasModel
     */
    lat: number;
    /**
     * Longitud
     * @type {number}
     * @memberof CoordenadasModel
     */
    lon: number;
}
/**
 *
 * @export
 * @interface CrearPartidaBody
 */
export interface CrearPartidaBody {
    /**
     * Id de la provincia donde se juega
     * @type {number}
     * @memberof CrearPartidaBody
     */
    idProvincia?: number;
    /**
     * Cantidad de municipios que se usan
     * @type {number}
     * @memberof CrearPartidaBody
     */
    cantidadMunicipios?: number;
    /**
     * Jugadores
     * @type {Array<number>}
     * @memberof CrearPartidaBody
     */
    idJugadores?: Array<number>;
    /**
     *
     * @type {ModoDeJuegoModel}
     * @memberof CrearPartidaBody
     */
    modoDeJuego?: ModoDeJuegoModel;
}
/**
 * Datos de una partida. Incluye su provincia en juego y el usuario que tiene el proximo turno.
 * @export
 * @interface DatosDeJuegoModel
 */
export interface DatosDeJuegoModel {
    /**
     *
     * @type {number}
     * @memberof DatosDeJuegoModel
     */
    idUsuarioProximoTurno?: number;
    /**
     * Municipios en juego que contiene la provincia.
     * @type {Array<MunicipioEnJuegoModel>}
     * @memberof DatosDeJuegoModel
     */
    municipios?: Array<MunicipioEnJuegoModel>;
}
/**
 *
 * @export
 * @interface EstadisticasDeJuegoModel
 */
export interface EstadisticasDeJuegoModel {
    /**
     *
     * @type {number}
     * @memberof EstadisticasDeJuegoModel
     */
    partidasCreadas?: number;
    /**
     *
     * @type {number}
     * @memberof EstadisticasDeJuegoModel
     */
    partidasEnCurso?: number;
    /**
     *
     * @type {number}
     * @memberof EstadisticasDeJuegoModel
     */
    partidasTerminadas?: number;
    /**
     *
     * @type {number}
     * @memberof EstadisticasDeJuegoModel
     */
    partidasCanceladas?: number;
}
/**
 *
 * @export
 * @interface EstadisticasDeUsuarioModel
 */
export interface EstadisticasDeUsuarioModel {
    /**
     *
     * @type {UsuarioModel}
     * @memberof EstadisticasDeUsuarioModel
     */
    usuario?: UsuarioModel;
    /**
     *
     * @type {number}
     * @memberof EstadisticasDeUsuarioModel
     */
    partidasJugadas?: number;
    /**
     *
     * @type {number}
     * @memberof EstadisticasDeUsuarioModel
     */
    partidasGanadas?: number;
    /**
     * Racha actual de victorias
     * @type {number}
     * @memberof EstadisticasDeUsuarioModel
     */
    rachaActual?: number;
}
/**
 * Estado de una partida.
 * @export
 * @enum {string}
 */
export enum EstadoDeJuegoModel {
    EnProgreso = <any> 'EnProgreso',
    Terminada = <any> 'Terminada',
    Cancelada = <any> 'Cancelada'
}
/**
 *
 * @export
 * @interface GoogleAuthModel
 */
export interface GoogleAuthModel {
    /**
     * Google Id Token del usuario
     * @type {string}
     * @memberof GoogleAuthModel
     */
    idToken: string;
}
/**
 *
 * @export
 * @interface ListarPartidasResponse
 */
export interface ListarPartidasResponse {
    /**
     *
     * @type {Array<PartidaModel>}
     * @memberof ListarPartidasResponse
     */
    partidas?: Array<PartidaModel>;
}
/**
 *
 * @export
 * @interface ListarProvinciasResponse
 */
export interface ListarProvinciasResponse {
    /**
     *
     * @type {Array<ProvinciaModel>}
     * @memberof ListarProvinciasResponse
     */
    provincias?: Array<ProvinciaModel>;
}
/**
 *
 * @export
 * @interface ListarUsuariosResponse
 */
export interface ListarUsuariosResponse {
    /**
     *
     * @type {Array<UsuarioModel>}
     * @memberof ListarUsuariosResponse
     */
    usuarios?: Array<UsuarioModel>;
}
/**
 * Modo de juego.
 * @export
 * @enum {string}
 */
export enum ModoDeJuegoModel {
    Rapido = <any> 'Rapido',
    Normal = <any> 'Normal',
    Extendido = <any> 'Extendido'
}
/**
 * Modo de operación de un municipio.
 * @export
 * @enum {string}
 */
export enum ModoDeMunicipioModel {
    Defensa = <any> 'Defensa',
    Produccion = <any> 'Produccion'
}
/**
 *
 * @export
 * @interface MoverGauchosBody
 */
export interface MoverGauchosBody {
    /**
     * Id del municipio de origen
     * @type {number}
     * @memberof MoverGauchosBody
     */
    idMunicipioOrigen?: number;
    /**
     * Id del municipio de destino
     * @type {number}
     * @memberof MoverGauchosBody
     */
    idMunicipioDestino?: number;
    /**
     * Cantidad de gauchos a mover
     * @type {number}
     * @memberof MoverGauchosBody
     */
    cantidad?: number;
}
/**
 *
 * @export
 * @interface MoverGauchosResponse
 */
export interface MoverGauchosResponse {
    /**
     *
     * @type {MunicipioEnJuegoModel}
     * @memberof MoverGauchosResponse
     */
    municipioOrigen?: MunicipioEnJuegoModel;
    /**
     *
     * @type {MunicipioEnJuegoModel}
     * @memberof MoverGauchosResponse
     */
    municipioDestino?: MunicipioEnJuegoModel;
}
/**
 * Municipio en juego.
 * @export
 * @interface MunicipioEnJuegoModel
 */
export interface MunicipioEnJuegoModel {
    /**
     * Id del municipio.
     * @type {number}
     * @memberof MunicipioEnJuegoModel
     */
    id?: number;
    /**
     * Nombre del municipio.
     * @type {string}
     * @memberof MunicipioEnJuegoModel
     */
    nombre?: string;
    /**
     *
     * @type {CoordenadasModel}
     * @memberof MunicipioEnJuegoModel
     */
    ubicacion?: CoordenadasModel;
    /**
     * Altura en metros del centroide del municipio
     * @type {number}
     * @memberof MunicipioEnJuegoModel
     */
    altura?: number;
    /**
     *
     * @type {UsuarioModel}
     * @memberof MunicipioEnJuegoModel
     */
    duenio?: UsuarioModel;
    /**
     * Cantidad de gauchos en el municipio
     * @type {number}
     * @memberof MunicipioEnJuegoModel
     */
    gauchos?: number;
    /**
     *
     * @type {number}
     * @memberof MunicipioEnJuegoModel
     */
    puntosDeDefensa?: number;
    /**
     *
     * @type {number}
     * @memberof MunicipioEnJuegoModel
     */
    produccionDeGauchos?: number;
    /**
     *
     * @type {ModoDeMunicipioModel}
     * @memberof MunicipioEnJuegoModel
     */
    modo?: ModoDeMunicipioModel;
    /**
     * Si el municipio está bloqueado.
     * @type {boolean}
     * @memberof MunicipioEnJuegoModel
     */
    estaBloqueado?: boolean;
    /**
     * URL a una imagen del municipio
     * @type {string}
     * @memberof MunicipioEnJuegoModel
     */
    urlImagen?: string;
}
/**
 *
 * @export
 * @interface NuevoJWTModel
 */
export interface NuevoJWTModel {
    /**
     *
     * @type {UsuarioModel}
     * @memberof NuevoJWTModel
     */
    usuario: UsuarioModel;
    /**
     * JWT que puede utilizarse para acceder a los recursos protegidos
     * @type {string}
     * @memberof NuevoJWTModel
     */
    token: string;
    /**
     * Token de refresh para generar un nuevo token de acceso
     * @type {string}
     * @memberof NuevoJWTModel
     */
    refreshToken?: string;
}
/**
 * Una partida
 * @export
 * @interface PartidaModel
 */
export interface PartidaModel {
    /**
     * Id de la partida
     * @type {number}
     * @memberof PartidaModel
     */
    id: number;
    /**
     *
     * @type {ProvinciaModel}
     * @memberof PartidaModel
     */
    provincia: ProvinciaModel;
    /**
     * Cantidad de municipios que se usan
     * @type {number}
     * @memberof PartidaModel
     */
    cantidadMunicipios: number;
    /**
     *
     * @type {EstadoDeJuegoModel}
     * @memberof PartidaModel
     */
    estado: EstadoDeJuegoModel;
    /**
     * Usuarios que juegan esta partida
     * @type {Array<UsuarioModel>}
     * @memberof PartidaModel
     */
    jugadores: Array<UsuarioModel>;
    /**
     *
     * @type {ModoDeJuegoModel}
     * @memberof PartidaModel
     */
    modoDeJuego: ModoDeJuegoModel;
    /**
     * Fecha de inicio de la partida
     * @type {string}
     * @memberof PartidaModel
     */
    fecha: string;
    /**
     *
     * @type {DatosDeJuegoModel}
     * @memberof PartidaModel
     */
    informacionDeJuego?: DatosDeJuegoModel;
    /**
     * Id del usuario ganador
     * @type {string}
     * @memberof PartidaModel
     */
    idGanador?: string;
}
/**
 * Una provincia.
 * @export
 * @interface ProvinciaModel
 */
export interface ProvinciaModel {
    /**
     * Id de la provincia
     * @type {number}
     * @memberof ProvinciaModel
     */
    id: number;
    /**
     * Nombre de la provincia
     * @type {string}
     * @memberof ProvinciaModel
     */
    nombre: string;
}
/**
 *
 * @export
 * @interface RefreshAccessTokenBody
 */
export interface RefreshAccessTokenBody {
    /**
     *
     * @type {string}
     * @memberof RefreshAccessTokenBody
     */
    refreshToken?: string;
}
/**
 *
 * @export
 * @interface ScoreboardResponse
 */
export interface ScoreboardResponse {
    /**
     *
     * @type {Array<EstadisticasDeUsuarioModel>}
     * @memberof ScoreboardResponse
     */
    scoreboard?: Array<EstadisticasDeUsuarioModel>;
}
/**
 *
 * @export
 * @interface SimularAtacarMunicipioBody
 */
export interface SimularAtacarMunicipioBody {
    /**
     * Id del municipio que ataca
     * @type {number}
     * @memberof SimularAtacarMunicipioBody
     */
    idMunicipioAtacante?: number;
    /**
     * Id del municipio atacado
     * @type {number}
     * @memberof SimularAtacarMunicipioBody
     */
    idMunicipioObjetivo?: number;
}
/**
 *
 * @export
 * @interface SimularAtacarMunicipioResponse
 */
export interface SimularAtacarMunicipioResponse {
    /**
     * Si el ataque fue exitoso en la simulación
     * @type {boolean}
     * @memberof SimularAtacarMunicipioResponse
     */
    exitoso?: boolean;
}
/**
 * Un usuario.
 * @export
 * @interface UsuarioModel
 */
export interface UsuarioModel {
    /**
     *
     * @type {number}
     * @memberof UsuarioModel
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof UsuarioModel
     */
    nombreDeUsuario: string;
}
/**
 * AdminApi - fetch parameter creator
 * @export
 */
export const AdminApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtiene las estadísticas generales del juego
         * @param {string} [fechaInicio]
         * @param {string} [fechaFin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstadisticas(fechaInicio?: string, fechaFin?: string, options: any = {}): FetchArgs {
            const localVarPath = `/admin/estadisticas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (fechaInicio !== undefined) {
                localVarQueryParameter['fechaInicio'] = (fechaInicio as any).toISOString();
            }

            if (fechaFin !== undefined) {
                localVarQueryParameter['fechaFin'] = (fechaFin as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Obtiene las estadísticas particulares de un usuario
         * @param {number} idUsuario Id del usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstadisticasDeUsuario(idUsuario: number, options: any = {}): FetchArgs {
            // verify required parameter 'idUsuario' is not null or undefined
            if (idUsuario === null || idUsuario === undefined) {
                throw new RequiredError('idUsuario','Required parameter idUsuario was null or undefined when calling getEstadisticasDeUsuario.');
            }
            const localVarPath = `/admin/estadisticas/usuarios/{idUsuario}`
                .replace(`{${"idUsuario"}}`, encodeURIComponent(String(idUsuario)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retorna los datos del scoreboard ordenados por partidas ganadas descendentemente.
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreboard(tamanioPagina?: number, pagina?: number, options: any = {}): FetchArgs {
            const localVarPath = `/admin/scoreboard`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (tamanioPagina !== undefined) {
                localVarQueryParameter['tamanioPagina'] = tamanioPagina;
            }

            if (pagina !== undefined) {
                localVarQueryParameter['pagina'] = pagina;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtiene las estadísticas generales del juego
         * @param {string} [fechaInicio]
         * @param {string} [fechaFin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstadisticas(fechaInicio?: string, fechaFin?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstadisticasDeJuegoModel> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).getEstadisticas(fechaInicio, fechaFin, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Obtiene las estadísticas particulares de un usuario
         * @param {number} idUsuario Id del usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstadisticasDeUsuario(idUsuario: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstadisticasDeUsuarioModel> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).getEstadisticasDeUsuario(idUsuario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retorna los datos del scoreboard ordenados por partidas ganadas descendentemente.
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreboard(tamanioPagina?: number, pagina?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreboardResponse> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).getScoreboard(tamanioPagina, pagina, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Obtiene las estadísticas generales del juego
         * @param {string} [fechaInicio]
         * @param {string} [fechaFin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstadisticas(fechaInicio?: string, fechaFin?: string, options?: any) {
            return AdminApiFp(configuration).getEstadisticas(fechaInicio, fechaFin, options)(fetch, basePath);
        },
        /**
         *
         * @summary Obtiene las estadísticas particulares de un usuario
         * @param {number} idUsuario Id del usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstadisticasDeUsuario(idUsuario: number, options?: any) {
            return AdminApiFp(configuration).getEstadisticasDeUsuario(idUsuario, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retorna los datos del scoreboard ordenados por partidas ganadas descendentemente.
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreboard(tamanioPagina?: number, pagina?: number, options?: any) {
            return AdminApiFp(configuration).getScoreboard(tamanioPagina, pagina, options)(fetch, basePath);
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     *
     * @summary Obtiene las estadísticas generales del juego
     * @param {string} [fechaInicio]
     * @param {string} [fechaFin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getEstadisticas(fechaInicio?: string, fechaFin?: string, options?: any) {
        return AdminApiFp(this.configuration).getEstadisticas(fechaInicio, fechaFin, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Obtiene las estadísticas particulares de un usuario
     * @param {number} idUsuario Id del usuario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getEstadisticasDeUsuario(idUsuario: number, options?: any) {
        return AdminApiFp(this.configuration).getEstadisticasDeUsuario(idUsuario, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retorna los datos del scoreboard ordenados por partidas ganadas descendentemente.
     * @param {number} [tamanioPagina]
     * @param {number} [pagina]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getScoreboard(tamanioPagina?: number, pagina?: number, options?: any) {
        return AdminApiFp(this.configuration).getScoreboard(tamanioPagina, pagina, options)(this.fetch, this.basePath);
    }

}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Loguea a un usuario validando su Google Id Token y retornando un JWT de la aplicación
         * @summary login
         * @param {GoogleAuthModel} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logIn(body: GoogleAuthModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling logIn.');
            }
            const localVarPath = `/auth/logIn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GoogleAuthModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Permite obtener un nuevo JWT
         * @param {RefreshAccessTokenBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(body?: RefreshAccessTokenBody, options: any = {}): FetchArgs {
            const localVarPath = `/auth/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RefreshAccessTokenBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registro a un usuario nuevo y retorna un JWT de la aplicación
         * @summary singUp
         * @param {GoogleAuthModel} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singUp(body: GoogleAuthModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling singUp.');
            }
            const localVarPath = `/auth/signUp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GoogleAuthModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Loguea a un usuario validando su Google Id Token y retornando un JWT de la aplicación
         * @summary login
         * @param {GoogleAuthModel} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logIn(body: GoogleAuthModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NuevoJWTModel> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).logIn(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                console.log('Sending JSON', localVarFetchArgs.options.body);
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Permite obtener un nuevo JWT
         * @param {RefreshAccessTokenBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(body?: RefreshAccessTokenBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NuevoJWTModel> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).refreshAccessToken(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registro a un usuario nuevo y retorna un JWT de la aplicación
         * @summary singUp
         * @param {GoogleAuthModel} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singUp(body: GoogleAuthModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NuevoJWTModel> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).singUp(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Loguea a un usuario validando su Google Id Token y retornando un JWT de la aplicación
         * @summary login
         * @param {GoogleAuthModel} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logIn(body: GoogleAuthModel, options?: any) {
            return AuthApiFp(configuration).logIn(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Permite obtener un nuevo JWT
         * @param {RefreshAccessTokenBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(body?: RefreshAccessTokenBody, options?: any) {
            return AuthApiFp(configuration).refreshAccessToken(body, options)(fetch, basePath);
        },
        /**
         * Registro a un usuario nuevo y retorna un JWT de la aplicación
         * @summary singUp
         * @param {GoogleAuthModel} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singUp(body: GoogleAuthModel, options?: any) {
            return AuthApiFp(configuration).singUp(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Loguea a un usuario validando su Google Id Token y retornando un JWT de la aplicación
     * @summary login
     * @param {GoogleAuthModel} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logIn(body: GoogleAuthModel, options?: any) {
        return AuthApiFp(this.configuration).logIn(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Permite obtener un nuevo JWT
     * @param {RefreshAccessTokenBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAccessToken(body?: RefreshAccessTokenBody, options?: any) {
        return AuthApiFp(this.configuration).refreshAccessToken(body, options)(this.fetch, this.basePath);
    }

    /**
     * Registro a un usuario nuevo y retorna un JWT de la aplicación
     * @summary singUp
     * @param {GoogleAuthModel} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public singUp(body: GoogleAuthModel, options?: any) {
        return AuthApiFp(this.configuration).singUp(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PartidasApi - fetch parameter creator
 * @export
 */
export const PartidasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Actualiza el estado de una partida
         * @param {number} idPartida
         * @param {PartidaModel} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizarEstadoPartida(idPartida: number, body?: PartidaModel, options: any = {}): FetchArgs {
            // verify required parameter 'idPartida' is not null or undefined
            if (idPartida === null || idPartida === undefined) {
                throw new RequiredError('idPartida','Required parameter idPartida was null or undefined when calling actualizarEstadoPartida.');
            }
            const localVarPath = `/partidas/{idPartida}`
                .replace(`{${"idPartida"}}`, encodeURIComponent(String(idPartida)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PartidaModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actualiza el estado de un municipio en juego
         * @param {number} idPartida
         * @param {number} idMunicipio
         * @param {MunicipioEnJuegoModel} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizarMunicipio(idPartida: number, idMunicipio: number, body?: MunicipioEnJuegoModel, options: any = {}): FetchArgs {
            // verify required parameter 'idPartida' is not null or undefined
            if (idPartida === null || idPartida === undefined) {
                throw new RequiredError('idPartida','Required parameter idPartida was null or undefined when calling actualizarMunicipio.');
            }
            // verify required parameter 'idMunicipio' is not null or undefined
            if (idMunicipio === null || idMunicipio === undefined) {
                throw new RequiredError('idMunicipio','Required parameter idMunicipio was null or undefined when calling actualizarMunicipio.');
            }
            const localVarPath = `/partidas/{idPartida}/municipios/{idMunicipio}`
                .replace(`{${"idPartida"}}`, encodeURIComponent(String(idPartida)))
                .replace(`{${"idMunicipio"}}`, encodeURIComponent(String(idMunicipio)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MunicipioEnJuegoModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Ataca a un municipio. Al atacar, se ataca con todos los gauchos del municipio atacante.
         * @param {number} idPartida
         * @param {AtacarMunicipioBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atacarMunicipio(idPartida: number, body?: AtacarMunicipioBody, options: any = {}): FetchArgs {
            // verify required parameter 'idPartida' is not null or undefined
            if (idPartida === null || idPartida === undefined) {
                throw new RequiredError('idPartida','Required parameter idPartida was null or undefined when calling atacarMunicipio.');
            }
            const localVarPath = `/partidas/{idPartida}/ataques`
                .replace(`{${"idPartida"}}`, encodeURIComponent(String(idPartida)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtacarMunicipioBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Crear una nueva partida
         * @param {CrearPartidaBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crearPartida(body?: CrearPartidaBody, options: any = {}): FetchArgs {
            const localVarPath = `/partidas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CrearPartidaBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retorna la partida con id: idPartida. Incluye los datos del juego.
         * @param {number} idPartida Id de la partida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartida(idPartida: number, options: any = {}): FetchArgs {
            // verify required parameter 'idPartida' is not null or undefined
            if (idPartida === null || idPartida === undefined) {
                throw new RequiredError('idPartida','Required parameter idPartida was null or undefined when calling getPartida.');
            }
            const localVarPath = `/partidas/{idPartida}`
                .replace(`{${"idPartida"}}`, encodeURIComponent(String(idPartida)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Permite listar partidas. No incluye los datos de juego asociados a las mismas.
         * @param {string} [fechaInicio]
         * @param {string} [fechaFin]
         * @param {EstadoDeJuegoModel} [estado]
         * @param {string} [ordenarPor] Campos por los que ordenar separados por coma. Los campos soportados son fecha y estado.
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarPartidas(fechaInicio?: string, fechaFin?: string, estado?: EstadoDeJuegoModel, ordenarPor?: string, tamanioPagina?: number, pagina?: number, options: any = {}): FetchArgs {
            const localVarPath = `/partidas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (fechaInicio !== undefined) {
                localVarQueryParameter['fechaInicio'] = (fechaInicio as any).toISOString();
            }

            if (fechaFin !== undefined) {
                localVarQueryParameter['fechaFin'] = (fechaFin as any).toISOString();
            }

            if (estado !== undefined) {
                localVarQueryParameter['estado'] = estado;
            }

            if (ordenarPor !== undefined) {
                localVarQueryParameter['ordenarPor'] = ordenarPor;
            }

            if (tamanioPagina !== undefined) {
                localVarQueryParameter['tamanioPagina'] = tamanioPagina;
            }

            if (pagina !== undefined) {
                localVarQueryParameter['pagina'] = pagina;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Mueve gauchos de un municipio a otro
         * @param {number} idPartida
         * @param {MoverGauchosBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moverGauchos(idPartida: number, body?: MoverGauchosBody, options: any = {}): FetchArgs {
            // verify required parameter 'idPartida' is not null or undefined
            if (idPartida === null || idPartida === undefined) {
                throw new RequiredError('idPartida','Required parameter idPartida was null or undefined when calling moverGauchos.');
            }
            const localVarPath = `/partidas/{idPartida}/movimientos`
                .replace(`{${"idPartida"}}`, encodeURIComponent(String(idPartida)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MoverGauchosBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Ataca a un municipio
         * @param {number} idPartida
         * @param {SimularAtacarMunicipioBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simularAtacarMunicipio(idPartida: number, body?: SimularAtacarMunicipioBody, options: any = {}): FetchArgs {
            // verify required parameter 'idPartida' is not null or undefined
            if (idPartida === null || idPartida === undefined) {
                throw new RequiredError('idPartida','Required parameter idPartida was null or undefined when calling simularAtacarMunicipio.');
            }
            const localVarPath = `/partidas/{idPartida}/ataques/simulaciones`
                .replace(`{${"idPartida"}}`, encodeURIComponent(String(idPartida)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SimularAtacarMunicipioBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartidasApi - functional programming interface
 * @export
 */
export const PartidasApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Actualiza el estado de una partida
         * @param {number} idPartida
         * @param {PartidaModel} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizarEstadoPartida(idPartida: number, body?: PartidaModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).actualizarEstadoPartida(idPartida, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Actualiza el estado de un municipio en juego
         * @param {number} idPartida
         * @param {number} idMunicipio
         * @param {MunicipioEnJuegoModel} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizarMunicipio(idPartida: number, idMunicipio: number, body?: MunicipioEnJuegoModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).actualizarMunicipio(idPartida, idMunicipio, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Ataca a un municipio. Al atacar, se ataca con todos los gauchos del municipio atacante.
         * @param {number} idPartida
         * @param {AtacarMunicipioBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atacarMunicipio(idPartida: number, body?: AtacarMunicipioBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtacarMunicipioResponse> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).atacarMunicipio(idPartida, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Crear una nueva partida
         * @param {CrearPartidaBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crearPartida(body?: CrearPartidaBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).crearPartida(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retorna la partida con id: idPartida. Incluye los datos del juego.
         * @param {number} idPartida Id de la partida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartida(idPartida: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PartidaModel> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).getPartida(idPartida, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Permite listar partidas. No incluye los datos de juego asociados a las mismas.
         * @param {string} [fechaInicio]
         * @param {string} [fechaFin]
         * @param {EstadoDeJuegoModel} [estado]
         * @param {string} [ordenarPor] Campos por los que ordenar separados por coma. Los campos soportados son fecha y estado.
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarPartidas(fechaInicio?: string, fechaFin?: string, estado?: EstadoDeJuegoModel, ordenarPor?: string, tamanioPagina?: number, pagina?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListarPartidasResponse> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).listarPartidas(fechaInicio, fechaFin, estado, ordenarPor, tamanioPagina, pagina, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Mueve gauchos de un municipio a otro
         * @param {number} idPartida
         * @param {MoverGauchosBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moverGauchos(idPartida: number, body?: MoverGauchosBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MoverGauchosResponse> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).moverGauchos(idPartida, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Ataca a un municipio
         * @param {number} idPartida
         * @param {SimularAtacarMunicipioBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simularAtacarMunicipio(idPartida: number, body?: SimularAtacarMunicipioBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimularAtacarMunicipioResponse> {
            const localVarFetchArgs = PartidasApiFetchParamCreator(configuration).simularAtacarMunicipio(idPartida, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PartidasApi - factory interface
 * @export
 */
export const PartidasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Actualiza el estado de una partida
         * @param {number} idPartida
         * @param {PartidaModel} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizarEstadoPartida(idPartida: number, body?: PartidaModel, options?: any) {
            return PartidasApiFp(configuration).actualizarEstadoPartida(idPartida, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Actualiza el estado de un municipio en juego
         * @param {number} idPartida
         * @param {number} idMunicipio
         * @param {MunicipioEnJuegoModel} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizarMunicipio(idPartida: number, idMunicipio: number, body?: MunicipioEnJuegoModel, options?: any) {
            return PartidasApiFp(configuration).actualizarMunicipio(idPartida, idMunicipio, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Ataca a un municipio. Al atacar, se ataca con todos los gauchos del municipio atacante.
         * @param {number} idPartida
         * @param {AtacarMunicipioBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atacarMunicipio(idPartida: number, body?: AtacarMunicipioBody, options?: any) {
            return PartidasApiFp(configuration).atacarMunicipio(idPartida, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Crear una nueva partida
         * @param {CrearPartidaBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crearPartida(body?: CrearPartidaBody, options?: any) {
            return PartidasApiFp(configuration).crearPartida(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retorna la partida con id: idPartida. Incluye los datos del juego.
         * @param {number} idPartida Id de la partida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartida(idPartida: number, options?: any) {
            return PartidasApiFp(configuration).getPartida(idPartida, options)(fetch, basePath);
        },
        /**
         *
         * @summary Permite listar partidas. No incluye los datos de juego asociados a las mismas.
         * @param {string} [fechaInicio]
         * @param {string} [fechaFin]
         * @param {EstadoDeJuegoModel} [estado]
         * @param {string} [ordenarPor] Campos por los que ordenar separados por coma. Los campos soportados son fecha y estado.
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarPartidas(fechaInicio?: string, fechaFin?: string, estado?: EstadoDeJuegoModel, ordenarPor?: string, tamanioPagina?: number, pagina?: number, options?: any) {
            return PartidasApiFp(configuration).listarPartidas(fechaInicio, fechaFin, estado, ordenarPor, tamanioPagina, pagina, options)(fetch, basePath);
        },
        /**
         *
         * @summary Mueve gauchos de un municipio a otro
         * @param {number} idPartida
         * @param {MoverGauchosBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moverGauchos(idPartida: number, body?: MoverGauchosBody, options?: any) {
            return PartidasApiFp(configuration).moverGauchos(idPartida, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Ataca a un municipio
         * @param {number} idPartida
         * @param {SimularAtacarMunicipioBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simularAtacarMunicipio(idPartida: number, body?: SimularAtacarMunicipioBody, options?: any) {
            return PartidasApiFp(configuration).simularAtacarMunicipio(idPartida, body, options)(fetch, basePath);
        },
    };
};

/**
 * PartidasApi - object-oriented interface
 * @export
 * @class PartidasApi
 * @extends {BaseAPI}
 */
export class PartidasApi extends BaseAPI {
    /**
     *
     * @summary Actualiza el estado de una partida
     * @param {number} idPartida
     * @param {PartidaModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public actualizarEstadoPartida(idPartida: number, body?: PartidaModel, options?: any) {
        return PartidasApiFp(this.configuration).actualizarEstadoPartida(idPartida, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Actualiza el estado de un municipio en juego
     * @param {number} idPartida
     * @param {number} idMunicipio
     * @param {MunicipioEnJuegoModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public actualizarMunicipio(idPartida: number, idMunicipio: number, body?: MunicipioEnJuegoModel, options?: any) {
        return PartidasApiFp(this.configuration).actualizarMunicipio(idPartida, idMunicipio, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Ataca a un municipio. Al atacar, se ataca con todos los gauchos del municipio atacante.
     * @param {number} idPartida
     * @param {AtacarMunicipioBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public atacarMunicipio(idPartida: number, body?: AtacarMunicipioBody, options?: any) {
        return PartidasApiFp(this.configuration).atacarMunicipio(idPartida, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Crear una nueva partida
     * @param {CrearPartidaBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public crearPartida(body?: CrearPartidaBody, options?: any) {
        return PartidasApiFp(this.configuration).crearPartida(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retorna la partida con id: idPartida. Incluye los datos del juego.
     * @param {number} idPartida Id de la partida
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public getPartida(idPartida: number, options?: any) {
        return PartidasApiFp(this.configuration).getPartida(idPartida, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Permite listar partidas. No incluye los datos de juego asociados a las mismas.
     * @param {string} [fechaInicio]
     * @param {string} [fechaFin]
     * @param {EstadoDeJuegoModel} [estado]
     * @param {string} [ordenarPor] Campos por los que ordenar separados por coma. Los campos soportados son fecha y estado.
     * @param {number} [tamanioPagina]
     * @param {number} [pagina]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public listarPartidas(fechaInicio?: string, fechaFin?: string, estado?: EstadoDeJuegoModel, ordenarPor?: string, tamanioPagina?: number, pagina?: number, options?: any) {
        return PartidasApiFp(this.configuration).listarPartidas(fechaInicio, fechaFin, estado, ordenarPor, tamanioPagina, pagina, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Mueve gauchos de un municipio a otro
     * @param {number} idPartida
     * @param {MoverGauchosBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public moverGauchos(idPartida: number, body?: MoverGauchosBody, options?: any) {
        return PartidasApiFp(this.configuration).moverGauchos(idPartida, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Ataca a un municipio
     * @param {number} idPartida
     * @param {SimularAtacarMunicipioBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartidasApi
     */
    public simularAtacarMunicipio(idPartida: number, body?: SimularAtacarMunicipioBody, options?: any) {
        return PartidasApiFp(this.configuration).simularAtacarMunicipio(idPartida, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ProvinciasApi - fetch parameter creator
 * @export
 */
export const ProvinciasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Permite listar las provincias
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarProvincias(tamanioPagina?: number, pagina?: number, options: any = {}): FetchArgs {
            const localVarPath = `/provincias`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (tamanioPagina !== undefined) {
                localVarQueryParameter['tamanioPagina'] = tamanioPagina;
            }

            if (pagina !== undefined) {
                localVarQueryParameter['pagina'] = pagina;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinciasApi - functional programming interface
 * @export
 */
export const ProvinciasApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Permite listar las provincias
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarProvincias(tamanioPagina?: number, pagina?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListarProvinciasResponse> {
            const localVarFetchArgs = ProvinciasApiFetchParamCreator(configuration).listarProvincias(tamanioPagina, pagina, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProvinciasApi - factory interface
 * @export
 */
export const ProvinciasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Permite listar las provincias
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarProvincias(tamanioPagina?: number, pagina?: number, options?: any) {
            return ProvinciasApiFp(configuration).listarProvincias(tamanioPagina, pagina, options)(fetch, basePath);
        },
    };
};

/**
 * ProvinciasApi - object-oriented interface
 * @export
 * @class ProvinciasApi
 * @extends {BaseAPI}
 */
export class ProvinciasApi extends BaseAPI {
    /**
     *
     * @summary Permite listar las provincias
     * @param {number} [tamanioPagina]
     * @param {number} [pagina]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinciasApi
     */
    public listarProvincias(tamanioPagina?: number, pagina?: number, options?: any) {
        return ProvinciasApiFp(this.configuration).listarProvincias(tamanioPagina, pagina, options)(this.fetch, this.basePath);
    }

}
/**
 * UsuariosApi - fetch parameter creator
 * @export
 */
export const UsuariosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Permite listar a los usuarios
         * @param {string} [filter]
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarUsuarios(filter?: string, tamanioPagina?: number, pagina?: number, options: any = {}): FetchArgs {
            const localVarPath = `/usuarios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (tamanioPagina !== undefined) {
                localVarQueryParameter['tamanioPagina'] = tamanioPagina;
            }

            if (pagina !== undefined) {
                localVarQueryParameter['pagina'] = pagina;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsuariosApi - functional programming interface
 * @export
 */
export const UsuariosApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Permite listar a los usuarios
         * @param {string} [filter]
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarUsuarios(filter?: string, tamanioPagina?: number, pagina?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListarUsuariosResponse> {
            const localVarFetchArgs = UsuariosApiFetchParamCreator(configuration).listarUsuarios(filter, tamanioPagina, pagina, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsuariosApi - factory interface
 * @export
 */
export const UsuariosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Permite listar a los usuarios
         * @param {string} [filter]
         * @param {number} [tamanioPagina]
         * @param {number} [pagina]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarUsuarios(filter?: string, tamanioPagina?: number, pagina?: number, options?: any) {
            return UsuariosApiFp(configuration).listarUsuarios(filter, tamanioPagina, pagina, options)(fetch, basePath);
        },
    };
};

/**
 * UsuariosApi - object-oriented interface
 * @export
 * @class UsuariosApi
 * @extends {BaseAPI}
 */
export class UsuariosApi extends BaseAPI {
    /**
     *
     * @summary Permite listar a los usuarios
     * @param {string} [filter]
     * @param {number} [tamanioPagina]
     * @param {number} [pagina]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public listarUsuarios(filter?: string, tamanioPagina?: number, pagina?: number, options?: any) {
        return UsuariosApiFp(this.configuration).listarUsuarios(filter, tamanioPagina, pagina, options)(this.fetch, this.basePath);
    }

}
